---
description: Tools and technical specs for the repo
globs: 
alwaysApply: false
---

# Map Painter .io Technical Architecture Specification

## Overview

Map Painter .io remains a real-time multiplayer .io game built with Next.js 15 and React 19, but with added flexibility:  
- **Optional Authentication:** Leverage [Clerk](mdc:https:/clerk.dev) to provide user authentication, enabling users to log in and get a personalized username. If they opt out, the system will assign a default username while still tracking key metrics.
- **Persistent Data Storage:** Use [Supabase](mdc:https:/supabase.com) to persist user data, game metrics, and analytics, complementing the existing Vercel KV layer for high-speed in-memory operations.

## Technology Stack

- **Framework:** Next.js 15 (using the app router for full-stack capabilities)
- **Language:** TypeScript 5.4+
- **Frontend:**
  - **React:** React 19 (concurrent rendering, new hooks like `useTransition`)
  - **Rendering:** PixiJS 8.x (with WebGPU support)
  - **State Management:** Redux Toolkit 2.x + RTK Query
  - **Component Library:** Shadcn/ui (Tailwind-based components)
- **Backend:**
  - **WebSocket:** `ws` integrated with a custom Next.js server
  - **Data Storage:** Vercel KV for in-memory speed (with **Supabase** for persistence)
- **Authentication & Metrics:** **Clerk** for optional user authentication and tracking metrics
- **Styling:** Tailwind CSS 3.4+
- **Testing:**
  - **Unit:** Vitest
  - **E2E:** Playwright
- **Tooling:**
  - **Linting:** ESLint 9.x (flat config)
  - **Formatting:** Prettier 3.x
  - **CI/CD:** GitHub Actions with Husky and lint-staged

## Repository Structure

```
map-painter-io/
├── src/
│   ├── app/                  # Next.js app router and game routes
│   ├── components/           # Reusable UI & game-specific components
│   ├── config/              # Game rules and map loader configuration
│   ├── lib/                 
│   │   ├── auth/             # Clerk authentication integration
│   │   └── persistence/      # Supabase persistence integration
│   ├── server/              # Server-side logic (game instances, WebSocket server, storage adapter)
│   ├── store/               # Redux Toolkit slices and RTK Query API
│   ├── types/               # Shared TypeScript types
│   ├── public/              # Static assets (GeoJSON maps)
│   └── tests/               # Unit and integration tests
├── e2e/                     # Playwright end-to-end tests
├── .github/                 # CI/CD workflows (GitHub Actions)
├── .husky/                  # Pre-commit hooks configuration
├── Config files             # ESLint, Prettier, Next.js, Tailwind, Vitest, etc.
└── README.md                # Project guide and high-level documentation
```

## Key Components

### Data Models

- **Player:** Contains `id`, `name`, `color`, `resources`, `ownedStates`, and (optionally) a Clerk-authenticated identifier.
- **State:** Represents each game state with `id`, an optional `ownerId`, `color`, and neighboring states.
- **GameInstance:** Aggregates the current game state, including maps of states and players, and a start timestamp.

### Authentication & Metrics (Optional)

- **Clerk Integration:**  
  - Use the Clerk Next.js SDK to wrap or protect routes.  
  - Users can log in to receive a personalized username; if they opt out (guest mode), assign a default username while still tracking metrics.
  - Optionally integrate Clerk’s built-in analytics or custom tracking to monitor user behavior.

### Persistence Layer with Supabase

- **Supabase Integration:**  
  - Set up a Supabase client using environment variables within Next.js.  
  - Create tables for persisting user metrics, game events, and session data.
  - Use Supabase’s real-time features if needed to complement the WebSocket updates.
  - Retain Vercel KV for high-speed, ephemeral game state updates while using Supabase for durable storage.

### Client Architecture

- **Map Rendering:** Handled by a PixiJS-powered `MapCanvas` component.
- **State Synchronization:** Managed via Redux Toolkit and RTK Query, with WebSocket connections for real-time updates.
- **Auth Handling:** Integrate Clerk’s React components for login/signup flows on the client. Provide a fallback for guest users.

### Server Architecture

- **Custom Next.js Server:**  
  - Integrate WebSocket support using `ws` for real-time communications.  
  - Incorporate Clerk middleware if auth is enabled.
- **Storage Layer:**  
  - Use Vercel KV for in-memory game state management.
  - Use Supabase for persistent data (user metrics, game logs, etc.) and potentially for reporting and analytics.

## Integration Details

### Clerk Integration

- **SDK Setup:**  
  - Install the Clerk SDK and configure it in your Next.js app (usually in a middleware or layout component).
  - Use Clerk’s hooks (e.g., `useUser`) to access user data in components.
- **Optional Flow:**  
  - Provide a “guest mode” where users can skip authentication, automatically assigning them a default username.
  - Ensure metrics and event tracking still work regardless of the authentication state.

### Supabase Integration

- **Client Initialization:**  
  - Set up the Supabase client in a dedicated file (e.g., `src/lib/persistence/supabaseClient.ts`).
  - Use environment variables for Supabase URL and keys.
- **Data Persistence:**  
  - Create API routes or service layers to interact with Supabase for CRUD operations on user metrics and game data.
  - Design tables for user profiles (even if optional), game sessions, and event logs.
  - Consider leveraging Supabase’s real-time subscriptions for additional reactive features if needed.
